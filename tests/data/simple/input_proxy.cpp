/*
                     * Generated by gdbus-codegen-glibmm 2.42.0. DO NOT EDIT.
                     *
                     * The license of this code is the same as for the source it was derived from.
                     */

#include "OUTPUT_DIR/input_proxy.h"
void org::gdbus::codegen::glibmm::Test::TestCall(
        gint32 arg_Param1,
        std::map<Glib::ustring,Glib::VariantBase> arg_Param2,
        const Gio::SlotAsyncReady &callback)
{
    Glib::VariantContainerBase base;
std::vector<Glib::VariantBase> params;
  Glib::Variant<gint32> Param1_param = Glib::Variant<gint32>::create(arg_Param1);
  params.push_back(Param1_param);
  Glib::Variant<std::map<Glib::ustring,Glib::VariantBase>> Param2_param = Glib::Variant<std::map<Glib::ustring,Glib::VariantBase>>::create(arg_Param2);
  params.push_back(Param2_param);
    base = Glib::VariantContainerBase::create_tuple(params);

    m_proxy->call(
        "TestCall",
        callback,
        base);
}

void org::gdbus::codegen::glibmm::Test::TestCall_finish(
        std::string& out_Param3,
        std::map<Glib::ustring,Glib::VariantBase>& out_Param4,

        const Glib::RefPtr<Gio::AsyncResult>& result)
{
    Glib::VariantContainerBase wrapped;
    wrapped = m_proxy->call_finish(result);

    Glib::Variant<Glib::ustring> out_Param3_v;
    wrapped.get_child(out_Param3_v,0);
    out_Param3 = out_Param3_v.get();

    Glib::Variant<std::map<Glib::ustring,Glib::VariantBase>> out_Param4_v;
    wrapped.get_child(out_Param4_v,1);
    out_Param4 = out_Param4_v.get();

}


std::vector<std::string> org::gdbus::codegen::glibmm::Test::TestPropReadStringArray_get() {
    std::vector<Glib::ustring> props = m_proxy->get_cached_property_names();
    Glib::Variant<std::vector<Glib::ustring> > b;
    if (std::find(props.begin(), props.end(), "TestPropReadStringArray") != props.end()) {
        m_proxy->get_cached_property(b, "TestPropReadStringArray");
    } else {
        g_print ("Todo: lookup value\n");
    }

    return TestTypeWrap::glibStringVecToStdStringVec(b.get());
}

void org::gdbus::codegen::glibmm::Test::handle_signal (const Glib::ustring& sender_name,
                                            const Glib::ustring& signal_name,
                                            const Glib::VariantContainerBase& parameters) {


if (signal_name == "TestSignalObjectPathArray") {
        if (parameters.get_n_children() != 1) { return; }
        Glib::Variant<std::vector<std::string> > base_Param1;
        parameters.get_child(base_Param1, 0);
        std::vector<std::string> p_Param1;
        p_Param1 = base_Param1.get();
        TestSignalObjectPathArray_signal.emit((p_Param1));
}

}


void org::gdbus::codegen::glibmm::Test::createForBus (
    Gio::DBus::BusType busType,
    Gio::DBus::ProxyFlags proxyFlags,
    const std::string &name,
    const std::string &objectPath,
    const Gio::SlotAsyncReady &slot) {
  Gio::DBus::Proxy::create_for_bus (busType,
      name,
      objectPath,
      "org.gdbus.codegen.glibmm.Test",
      slot,
      Glib::RefPtr<Gio::DBus::InterfaceInfo>(),
      proxyFlags);
}

Glib::RefPtr<org::gdbus::codegen::glibmm::Test> org::gdbus::codegen::glibmm::Test::createForBusFinish (Glib::RefPtr<Gio::AsyncResult> result) {
    Glib::RefPtr<Gio::DBus::Proxy> proxy = Gio::DBus::Proxy::create_for_bus_finish (result);
    org::gdbus::codegen::glibmm::Test *p = new org::gdbus::codegen::glibmm::Test (proxy);
    return Glib::RefPtr<org::gdbus::codegen::glibmm::Test> (p);
}
