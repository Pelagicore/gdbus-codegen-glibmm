/*
 * Generated by gdbus-codegen-glibmm {{ program_version }}. DO NOT EDIT.
 *
 * The license of this code is the same as for the source it was derived from.
 */

#include "{{ proxy_h_name }}"

#include <utility>

template<class T>
inline T specialGetter(Glib::Variant<T> variant)
{
    return variant.get();
}

template<>
inline std::string specialGetter(Glib::Variant<std::string> variant)
{
    // String is not guaranteed to be null-terminated, so don't use ::get()
    gsize n_elem;
    gsize elem_size = sizeof(char);
    char* data = (char*)g_variant_get_fixed_array(variant.gobj(), &n_elem, elem_size);

    return std::string(data, n_elem);
}

{% for interface in interfaces %}
{% set class_name_with_namespace = interface.cpp_namespace_name + '::' + interface.cpp_class_name_proxy %}
{% for method in interface.methods %}
{% if method.doc_string %}
/**
{% for line in method.doc_string.lines %}
 * {{ line }}
{% endfor %}
 */
{% endif %}
void {{ class_name_with_namespace }}::{{ method.camel_name }}(
    {% for arg in method.in_args %}
    {{ arg.cpptype_in }} arg_{{ arg.name }},
    {% endfor %}
    const Gio::SlotAsyncReady &callback,
    const Glib::RefPtr<Gio::Cancellable> &cancellable,
    int timeout_msec)
{
    Glib::VariantContainerBase base;
    {% if method.in_args|length > 0 %}
    base = {{ interface.cpp_class_name }}TypeWrap::{{ method.camel_name }}_pack(
    {%- set comma = joiner(',') -%}
    {%- for arg in method.in_args -%}
        {{ comma() }}
        arg_{{ arg.name }}
    {%- endfor -%});
    {% endif %}

    m_proxy->call("{{ method.name }}", callback, cancellable, base, timeout_msec);
}

void {{ class_name_with_namespace }}::{{ method.camel_name }}_finish(
    {% for arg in method.out_args %}
    {{ arg.cpptype_out }} &out_{{ arg.name }},
    {% endfor %}
    const Glib::RefPtr<Gio::AsyncResult> &result)
{
    Glib::VariantContainerBase wrapped;
    wrapped = m_proxy->call_finish(result);
    {% for arg in method.out_args %}

    {{ arg.cppvalue_get("out_" + arg.name, loop.index0|string, interface.cpp_class_name) | indent(1) }}
    {% endfor %}
}

{% if method.out_args|length == 0 %}
void
{% elif method.out_args|length == 1 %}
{{ method.out_args[0].cpptype_out }}
{% else %}
std::tuple<{{ method.out_args|join(', ', attribute='cpptype_out') }}>
{% endif %}
{{ class_name_with_namespace }}::{{ method.camel_name }}_sync(
    {% for arg in method.in_args %}
    {{ arg.cpptype_in }} arg_{{ arg.name }},
    {% endfor %}
    const Glib::RefPtr<Gio::Cancellable> &cancellable,
    int timeout_msec)
{
    Glib::VariantContainerBase base;
    {% if method.in_args|length > 0 %}
    base = {{ interface.cpp_class_name }}TypeWrap::{{ method.camel_name }}_pack(
    {%- set comma = joiner(',') -%}
    {%- for arg in method.in_args -%}
        {{ comma() }}
        arg_{{ arg.name }}
    {%- endfor -%});
    {% endif %}

    Glib::VariantContainerBase wrapped;
    wrapped = m_proxy->call_sync("{{ method.name }}", cancellable, base, timeout_msec);

{% if method.out_args|length == 1 %}
    {% set arg = method.out_args[0] %}
    {{ arg.cpptype_out }} out_{{ arg.name }};
    {{ arg.cppvalue_get("out_" + arg.name, "0", interface.cpp_class_name) | indent(1) }}
    return out_{{ arg.name }};
{% elif method.out_args|length > 1 %}
    {% for arg in method.out_args %}
    {{ arg.cpptype_out }} out_{{ arg.name }};
    {{ arg.cppvalue_get("out_" + arg.name, loop.index0|string, interface.cpp_class_name) | indent(1) }}

    {% endfor %}
    return std::make_tuple(
    {% for arg in method.out_args %}
        std::move(out_{{ arg.name }}){{ "," if not loop.last }}
    {% endfor %}
    );
{% endif %}
}

{% endfor %}
{% for prop in interface.properties %}
{% if prop.readable %}
{{ prop.cpptype_out }} {{ class_name_with_namespace }}::{{ prop.name }}_get(bool *ok)
{
    Glib::Variant<{{ prop.variant_type }}> b;
    m_proxy->get_cached_property(b, "{{ prop.name }}");
    if (b) {
        if (ok) {
            *ok = true;
        }
        return {{ prop.cpptype_get_cast }}(specialGetter(b));
    } else {
        if (ok) {
            *ok = false;
        } else {
            g_warning("Unhandled error while getting property {{ prop.name }}");
        }
        return {{ prop.cpptype_out }}();
    }

}

{% endif %}
{% if prop.writable %}
void {{ class_name_with_namespace }}::{{ prop.name }}_set({{ prop.cpptype_in }} value, const Gio::SlotAsyncReady &cb)
{
    std::vector<Glib::VariantBase> paramsVec;
    paramsVec.push_back(Glib::Variant<Glib::ustring>::create("{{ interface.name }}"));
    paramsVec.push_back(Glib::Variant<Glib::ustring>::create("{{ prop.name }}"));
    {% if prop.signature == "ay" %}
    gsize len;
    char *data;

    len = value.size();
    data = g_strndup (value.c_str(), len);

    GVariant * newVar = g_variant_new_from_data (G_VARIANT_TYPE ("ay"), data, len, TRUE, g_free, data);

    paramsVec.push_back(Glib::Variant<Glib::VariantBase>::create(Glib::Variant<std::string>(newVar)));
    {% else %}
    paramsVec.push_back(Glib::Variant<Glib::VariantBase>::create(Glib::Variant<{{ prop.variant_type }}>::create({{ prop.cpptype_to_dbus }}(value))));
    {% endif %}

    Glib::VariantContainerBase params = Glib::VariantContainerBase::create_tuple(paramsVec);
    m_proxy->call("org.freedesktop.DBus.Properties.Set", cb, params);
}

void {{ class_name_with_namespace }}::{{ prop.name }}_set_finish(const Glib::RefPtr<Gio::AsyncResult> &result) {
    m_proxy->call_finish(result);
}

void {{ class_name_with_namespace }}::{{ prop.name }}_set_sync({{ prop.cpptype_in }} value) {
    std::vector<Glib::VariantBase> paramsVec;
    paramsVec.push_back(Glib::Variant<Glib::ustring>::create("{{ interface.name }}"));
    paramsVec.push_back(Glib::Variant<Glib::ustring>::create("{{ prop.name }}"));
    paramsVec.push_back(Glib::Variant<Glib::VariantBase>::create(Glib::Variant<{{ prop.variant_type }}>::create({{ prop.cpptype_to_dbus }}(value))));
    Glib::VariantContainerBase params = Glib::VariantContainerBase::create_tuple(paramsVec);
    m_proxy->call_sync("org.freedesktop.DBus.Properties.Set", params);
}

{% endif %}
{% endfor %}
{% for signal in interface.signals if signal is supported_by_sigc %}
{% if signal.doc_string %}
/**
{% for line in signal.doc_string.lines %}
 * {{ line }}
{% endfor %}
 */

{% endif %}
{% endfor %}
void {{ class_name_with_namespace }}::handle_signal(const Glib::ustring&/* sender_name */,
    const Glib::ustring& signal_name,
    const Glib::VariantContainerBase& parameters)
{
    static_cast<void>(signal_name); // maybe unused
    static_cast<void>(parameters); // maybe unused

{% for signal in interface.signals if signal is supported_by_sigc %}
    if (signal_name == "{{ signal.name }}") {
    {% for arg in signal.args %}
        if (parameters.get_n_children() != {{ loop.length|string }}) return;
        Glib::Variant<{{ arg.variant_type }}> base_{{ arg.name }};
        parameters.get_child(base_{{ arg.name }}, {{ loop.index0 }});
        {{ arg.variant_type }} p_{{ arg.name }};
        p_{{ arg.name }} = base_{{ arg.name }}.get();

    {% endfor %}
        {{ signal.name }}_signal.emit(
            {%- set comma = joiner() -%}
            {%- for arg in signal.args -%}
            {{ comma() }}{{ arg.cpptype_get_cast }}(p_{{ arg.name }})
            {%- endfor -%});
    }
{% endfor %}
}

void {{ class_name_with_namespace }}::handle_properties_changed(
    const Gio::DBus::Proxy::MapChangedProperties &changed_properties,
    const std::vector<Glib::ustring> &/* invalidated_properties */)
{
    static_cast<void>(changed_properties); // maybe unused

    // Only check changed_properties since value will already be cached. Glib can be setup to get
    // values of invalidated properties in which case property will be in changed_properties when
    // value is actually received. See Gio::DBus::ProxyFlags::PROXY_FLAGS_GET_INVALIDATED_PROPERTIES .

{% for prop in interface.properties %}
    if (changed_properties.find("{{ prop.name }}") != changed_properties.cend())
        m_{{ prop.name }}_changed.emit();
{% endfor %}
}

{{ class_name_with_namespace }}::{{ interface.cpp_class_name_proxy }}(const Glib::RefPtr<Gio::DBus::Proxy> &proxy) : m_proxy(proxy)
{
    m_proxy->signal_signal().connect(sigc::mem_fun(this, &{{ interface.cpp_class_name_proxy }}::handle_signal));
    m_proxy->signal_properties_changed().
        connect(sigc::mem_fun(this, &{{ interface.cpp_class_name_proxy }}::handle_properties_changed));
{% if interface.errors %}
    {{ interface.errors_namespace }}::Error::initialize();
{% endif %}
}

void {{ class_name_with_namespace }}::createForBus(
    Gio::DBus::BusType busType,
    Gio::DBus::ProxyFlags proxyFlags,
    const std::string &name,
    const std::string &objectPath,
    const Gio::SlotAsyncReady &slot,
    const Glib::RefPtr<Gio::Cancellable> &cancellable)
{
    Gio::DBus::Proxy::create_for_bus(busType,
        name,
        objectPath,
        "{{ interface.name }}",
        slot,
        cancellable,
        Glib::RefPtr<Gio::DBus::InterfaceInfo>(),
        proxyFlags);
}

Glib::RefPtr<{{ class_name_with_namespace }}> {{ class_name_with_namespace }}::createForBusFinish(const Glib::RefPtr<Gio::AsyncResult> &result)
{
    Glib::RefPtr<Gio::DBus::Proxy> proxy =
        Gio::DBus::Proxy::create_for_bus_finish(result);
    {{ class_name_with_namespace }} *p =
        new {{ class_name_with_namespace }}(proxy);
    return Glib::RefPtr<{{ class_name_with_namespace }}>(p);
}

Glib::RefPtr<{{ class_name_with_namespace }}> {{ class_name_with_namespace }}::createForBus_sync(
    Gio::DBus::BusType busType,
    Gio::DBus::ProxyFlags proxyFlags,
    const std::string &name,
    const std::string &objectPath,
    const Glib::RefPtr<Gio::Cancellable> &cancellable)
{
    Glib::RefPtr<Gio::DBus::Proxy> proxy =
        Gio::DBus::Proxy::create_for_bus_sync(busType,
            name,
            objectPath,
            "{{ interface.name }}",
            cancellable,
            Glib::RefPtr<Gio::DBus::InterfaceInfo>(),
            proxyFlags);
    {{ class_name_with_namespace }} *p =
        new {{ class_name_with_namespace }}(proxy);
    return Glib::RefPtr<{{ class_name_with_namespace }}>(p);
}
{%- endfor %}

